import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { firstValueFrom } from 'rxjs';

@Component({
  selector: 'app-complete-registration',
  standalone: true,
  templateUrl: './complete-registration.component.html',
  styleUrls: ['./complete-registration.component.css'],
  imports: [CommonModule, ReactiveFormsModule]
})
export class CompleteRegistrationComponent implements OnInit {
  registrationForm: FormGroup;
  errorMessage: string | null = null;
  successMessage: string | null = null;
  isSubmitting: boolean = false;
  selectedFile: File | null = null;
  fileError: string | null = null;

  constructor(
    private fb: FormBuilder,
    private route: ActivatedRoute,
    private router: Router,
    private http: HttpClient
  ) {
    this.registrationForm = this.fb.group({
      rut: ['', Validators.required],
      primerNombre: ['', Validators.required],
      segundoNombre: [''],
      apellidoPaterno: ['', Validators.required],
      apellidoMaterno: ['', Validators.required],
      direccion: ['', Validators.required],
      usuario: ['', Validators.required],
      correo: [{ value: '', disabled: true }, [Validators.required, Validators.email]]
    });
  }

  ngOnInit(): void {
    this.route.queryParams.subscribe(params => {
      const email = params['email'];
      const name = params['name'] || '';
      
      this.registrationForm.patchValue({
        correo: email,
        primerNombre: name.split(' ')[0] || '',
        apellidoPaterno: name.split(' ').slice(1).join(' ') || ''
      });

      // Split full name into parts
      const nameParts = name.split(' ');
      this.registrationForm.patchValue({
        correo: email,
        primerNombre: nameParts[0] || '',
        segundoNombre: nameParts.length > 2 ? nameParts[1] : '',
        apellidoPaterno: nameParts.length > 1 ? (nameParts.length > 2 ? nameParts[2] : nameParts[1]) : ''
        // Note: apellidoMaterno will need to be entered manually
      });
    });
  }

  // Method to reset form state
  resetFormState(): void {
    this.isSubmitting = false;
    this.errorMessage = null;
    this.successMessage = null;
    this.selectedFile = null;
    this.fileError = null;
    this.registrationForm.enable();
    this.registrationForm.get('correo')?.disable(); // Keep email disabled
  }

  onFileSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length > 0) {
      const file = input.files[0];
      const fileType = file.type;
      
      // Validate file type
      if (fileType.startsWith('image/') || fileType === 'application/pdf') {
        this.selectedFile = file;
        this.fileError = null;
        
        // Debug: Log file information
        console.log('Selected file:', {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified
        });
      } else {
        this.selectedFile = null;
        this.fileError = 'Por favor, selecciona un archivo PDF o una imagen.';
      }
    }
  }

  // Debug method to test request format
  testRequestFormat(): void {
    const formData = new FormData();
    formData.append('testField', 'testValue');
    
    if (this.selectedFile) {
      formData.append('file', this.selectedFile, this.selectedFile.name);
    }
    
    console.log('=== REQUEST DEBUG INFO ===');
    console.log('FormData entries:');
    for (let [key, value] of formData.entries()) {
      console.log(`${key}:`, value);
    }
    
    // Test request without actually sending
    const testRequest = this.http.post('http://localhost:8080/api/registro-completo', formData);
    console.log('Request object:', testRequest);
    
    // Check if Content-Type is being set automatically
    console.log('=== CHECK BROWSER NETWORK TAB ===');
    console.log('1. Open DevTools (F12)');
    console.log('2. Go to Network tab');
    console.log('3. Submit the form');
    console.log('4. Look for the request to /api/registro-completo');
    console.log('5. Check that Content-Type is: multipart/form-data; boundary=...');
    console.log('6. The boundary should be automatically generated by the browser');
  }

  async onSubmit(): Promise<void> {
    if (this.registrationForm.valid && !this.isSubmitting) {
      this.isSubmitting = true;
      this.errorMessage = null;

      try {
        const formData = new FormData();
        const formValue = this.registrationForm.getRawValue();

        // Append all form fields to FormData
        Object.keys(formValue).forEach(key => {
          formData.append(key, formValue[key]);
        });

        // Append role, state, and provider
        formData.append('rol', JSON.stringify({ id: 2 })); // USER
        formData.append('estado', JSON.stringify({ id: 1 })); // ACTIVO
        formData.append('proveedorAutenticacion', 'azure');

        // Append file if selected
        if (this.selectedFile) {
          formData.append('file', this.selectedFile, this.selectedFile.name);
        }
        
        // Debug: Log FormData contents (for development only)
        console.log('FormData contents:');
        for (let [key, value] of formData.entries()) {
          console.log(`${key}:`, value);
        }
        
        // Use the correct endpoint that handles multipart/form-data
        // IMPORTANT: Do NOT set Content-Type header - let browser handle it automatically
        const response = await firstValueFrom(this.http.post('http://localhost:8080/api/registro-completo', formData));
        
        console.log('Registration successful:', response);
        this.successMessage = "¡Registro completado! Serás redirigido al dashboard.";
        
        // Prevent any further submissions
        this.registrationForm.disable();
        
        setTimeout(() => this.router.navigate(['/dashboard']), 2000);

      } catch (error: any) {
        console.error('Registration error:', error);
        
        // Enhanced error handling with specific messages for duplicates
        if (error.status === 0) {
          this.errorMessage = 'Error de conexión: No se pudo conectar al servidor.';
        } else if (error.status === 400) {
          const errorMessage = error.error || 'Error desconocido';
          
          // Check for specific duplicate errors
          if (errorMessage.includes('RUT ya existe')) {
            this.errorMessage = 'El RUT ingresado ya está registrado en el sistema.';
          } else if (errorMessage.includes('correo electrónico ya está registrado')) {
            this.errorMessage = 'El correo electrónico ya está registrado.';
          } else if (errorMessage.includes('nombre de usuario ya está en uso')) {
            this.errorMessage = 'El nombre de usuario ya está en uso. Por favor, elige otro.';
          } else {
            this.errorMessage = errorMessage;
          }
        } else if (error.status === 413) {
          this.errorMessage = 'El archivo es demasiado grande.';
        } else if (error.status === 415) {
          this.errorMessage = 'Tipo de archivo no soportado.';
        } else if (error.status >= 500) {
          this.errorMessage = 'Error del servidor. Inténtalo de nuevo más tarde.';
        } else {
          this.errorMessage = error.error?.message || 'Hubo un error al completar el registro.';
        }
      } finally {
        this.isSubmitting = false;
      }
    } else if (this.isSubmitting) {
      // Prevent multiple submissions
      console.log('Form submission already in progress, ignoring duplicate request');
    } else {
      this.registrationForm.markAllAsTouched();
    }
  }
} 